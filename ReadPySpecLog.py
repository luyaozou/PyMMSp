# encoding = utf8
''' This script is used to scan through the log files generated by
PySpec.py, and read out fitting parameters. Alternatively, it can also
generate an artificial spectra convolved with Gaussian with all fitting
parameters read. '''

import re
import argparse
import numpy as np
from math import pi

def g(x, mu, sigma, a):
    ''' Gaussian function '''
    return abs(a)/(np.sqrt(2*pi)*sigma)*np.exp(-(x-mu)**2/(2*sigma**2))

def regulate(x, y, resol=0.05, rescale_x=0.01):
    ''' Regulate x points into a fixed step size and sum up y value. '''
    # calculate number of steps from start point, round to integer
    step_num = np.ceil((x - np.amin(x))/resol)
    # find unique values of x and corresponding index
    x_reg, x_unique_idx = np.unique(step_num, return_index=True)
    x_reg = np.amin(x) + x_reg*resol
    y_reg = np.array([])
    # count for occurance
    x_occurance = np.append(np.diff(x_unique_idx), len(x)-x_unique_idx[-1])
    # extract y values at each unique x point
    for i in range(len(x_unique_idx)):
        xid_start = x_unique_idx[i]
        xid_end = xid_start + x_occurance[i]
        y_reg = np.append(y_reg, np.average(y[xid_start:xid_end]))
    return np.column_stack((x_reg*rescale_x, y_reg))


# parse arguments
parser = argparse.ArgumentParser(description=__doc__,
                epilog='--- Luyao Zou @ https://github.com/luyaozou/ ---')
parser.add_argument('log', nargs='+', help='List log files')
parser.add_argument('-o', '--out', nargs=1, help='Specify output file name')
parser.add_argument('-spectra', action='store_true',
                    help='''Generate an artificial spectra convolved with
                            Gaussian using all lines read in''')
args = parser.parse_args()
log_list = args.log

if args.out:
    out_name = args.out[0]
else:
    if args.spectra:
        out_name = 'FitSimSpectra.txt'
    else:
        out_name = 'FitLogSummary.csv'

# initialization
mu = []
sigma = []
a = []
err_mu = []
err_sigma = []
err_a = []
snr = []
file_name = []

for log_name in log_list:
    with open(log_name, 'r') as log_file:
        log_content = log_file.readlines()
#        counter = 0
        for log_line in log_content:
            try:
                parameters = re.match('(\D{5})[ ]*(-?\d+.\d+) \((\d+.\d+)\)',
                                      log_line).groups()
                if 'mu' in parameters[0]:
                    mu.append(parameters[1])
                    err_mu.append(parameters[2])
                    file_name.append(log_name)
                elif 'sigma' in parameters[0] or 'gamma' in parameters[0]:
                    sigma.append(parameters[1])
                    err_sigma.append(parameters[2])
                elif 'A' in parameters[0]:
                    a.append(parameters[1])
                    err_a.append(parameters[2])
                else:
                    pass
            except AttributeError:
                pass
# Don't need snr anymore. It's not realiable
#            try:
#                snr_max = re.match('max\(SnR\) = (\d+.\d+)', log_line).group(1)
#            except AttributeError:
#                pass
#        for k in range(counter):
#            snr.append(snr_max)

line_freq = np.array(mu, dtype=float)
sort_idx = np.argsort(line_freq)

# write summary file
if not args.spectra:
    # construct output table
    out_tbl = []
    for j in range(len(sort_idx)):
        i = sort_idx[j]
        row = ','.join([file_name[i], mu[i], err_mu[i], sigma[i],
                        err_sigma[i], a[i], err_a[i]])
        out_tbl.append(row)
    with open(out_name, 'w') as out_file:
        out_file.write(','.join(['filename', 'mu', 'err_mu', 'sigma',
                                 'err_sigma', 'A', 'err_A\n']))
        for row in out_tbl:
            out_file.write(row+'\n')
    print(out_name + ' saved!')
# generate and save spectra
else:
    # claim fullx, fully
    fullx = np.array([1], dtype=float)
    fully = np.array([1], dtype=float)
    for j in range(len(sort_idx)):
        i = sort_idx[j]
        # get +/- 10 sigma frequency window and 0.2 sigma resolution
        window = 20*float(sigma[i])
        resol = window/100
        # create x-array w/ frequency resolution of 0.002 sigma
        x = np.arange(100)*resol + line_freq[i] - window/2
        # create y-array
        y = g(x, line_freq[i], float(sigma[i]), float(a[i])/float(err_a[i]))
        # append x, y to full array
        fullx = np.append(fullx, x)
        fully = np.append(fully, y)
    # delete the first number of fullx and fully
    fullx = np.delete(fullx, 0)
    fully = np.delete(fully, 0)
    sort_x_idx = np.argsort(fullx)
    # regulate x points into 100kHz resolution
    # & rescale x to 100MHz unit so the values are on the scale of MW data
    out_tbl = regulate(fullx[sort_x_idx], fully[sort_x_idx],
                       resol=0.1, rescale_x=0.01)
    # save xy file
    np.savetxt(out_name, out_tbl, delimiter=' ', fmt='%.6f')
    print(out_name + ' saved!')
